===== MANDATORY PART =====

-> handleNewConnection listen and accept every client, by adding non-blocking socket to epoll
-> request is read/parsed in handleClientRead.

    I/O Multiplexing
-> loop relies on epoll_wait, called in epollManager::run
-> avoid blocking on a single socket

    epoll working
-> epoll_wait wakes up as soon as an fd is ready
-> EPOLLIN event : handleClientRead is called, EPOLLOUT event : handleClientWrite is called
-> After a complete read, the write is armed via armWriteEvent, which rewrites the fd with EPOLLIN|EPOLLOUT 
-> allows reading and writing in the same loop without blocking

    Ask if they use only one select() (or equivalent) and how they've managed the server to accept and the client to read/write.
-> in main, loop.run calls the only epoll_wait

    The select() (or equivalent) should be in the main loop and should check file descriptors for read and write AT THE SAME TIME. If not, the grade is 0 and the evaluation process ends now.
-> loop.run (in main) : single epoll_wait in epollManager::run    

    There should be only one read or one write per client per select() (or equivalent). Ask the group to show you the code from the select() (or equivalent) to the read and write of a client.
-> handleClientRead and handleClientWrite only call recv/send once.     

    Search for all read/recv/write/send on a socket and check that, if an error is returned, the client is removed.
-> epollManager::handleClientRead : else if (bytesRead == 0) { closeClient(clientFd); }

    Search for all read/recv/write/send and check if the returned value is correctly checked (checking only -1 or 0 values is not enough, both should be checked).
-> handleClientRead, handleClientWrite, startCgiFor, handleCgiOutEvent, CgiHandler::execute, readParseCGI : OK 

    If errno is checked after read/recv/write/send, the grade is 0 and the evaluation process ends now.
-> epollManager::handleClientRead , epollManager::handleClientWrite, epollManager::handleCgiOutEvent, epollManager::handleCgiInEvent

    Writing or reading ANY file descriptor without going through the select() (or equivalent) is strictly FORBIDDEN.
-> handleClientRead, handleClientWrite, 




===== CONFIG =====

    HTTP response status codes
-> 200/201/204, 301/302, 400/403/404/405/408/411/413, 500/504/503/505

    Setup multiple servers with different ports
-> Each .conf file has 2 servers bloc with different ports (8080/8081/8082)

    Setup multiple servers with different hostnames
-> default.conf : server_name = localhost / localhost-alt
-> linux.conf : server_name = localhost / api.local
-> curl --resolve localhost-alt:8081:127.0.0.1 http://localhost-alt:8081/
-> curl --resolve api.local:8082:127.0.0.1 http://api.local:8082/health

    Setup default error page (try to change the error 404)
-> .conf : error_page 404 /404.html;
-> curl -i http://127.0.0.1:8080/absent

    Limit the client body
-> .conf : client_max_body_size directive
-> epollManager::handlePost , (request.getBody().size() > maxBody { response.setStatus(413)}) l.692
-> curl -i -F "file=@small.txt" http://127.0.0.1:8080/

    Setup routes in a server to different directories
-> every location block leads to a different directory

    Setup a default file to search for if you ask for a directory
-> each 'server' and 'location' bloc specify index index.html
-> curl -i http://127.0.0.1:8080/

    Setup a list of methods accepted for a certain route
-> curl -i http://127.0.0.1:8080/ : 200 OK
-> curl -i -X DELETE http://127.0.0.1:8080/ : 405 Method Not Allowed



===== Basic checks =====

    GET, POST and DELETE requests should work.
-> GET via curl : curl -i http://127.0.0.1:8080/test-get.txt : 200 OK
-> GET via telnet : telnet 127.0.0.1 8080
-> POST : curl -i -X POST \
     -d "name=chatgpt" \
     http://127.0.0.1:8080/cgi-bin/test.py : 200 OK
-> DELETE : curl -i -X DELETE http://127.0.0.1:8080/uploads/to-delete.txt : 204 no-content

    UNKNOWN requests should not result in a crash.
-> curl -i -X FOO http://127.0.0.1:8080/ : 405 Method Not Allowed




===== Check CGI =====

    The server is working fine using a CGI.
-> curl -i http://127.0.0.1:8080/cgi-bin/test.py : 200 OK
-> curl -i http://127.0.0.1:8080/cgi-bin/test.php : 200 OK
-> curl -i http://127.0.0.1:8080/cgi-bin/test.pl : 200 OK
-> curl -i http://127.0.0.1:8080/cgi-bin/test.sh : 200 OK
-> server can launch multiple interpreters via cgi_pass

    CGI should be run in the correct directory for relative path file access
-> epollManager::startCgiFor
-> std::string dir = dirnameOf(scriptPath); chdir(dir.c_str()); : chdir to script directory
-> fork then chdir to move in script folder , then execve.

    Test the CGI with the "GET" and "POST" methods
-> curl -i http://127.0.0.1:8080/cgi-bin/test.py : 200 OK
-> curl -i -X POST \
     -H "Content-Type: application/x-www-form-urlencoded" \
     --data "name=webserv&lang=cpp" \
     http://127.0.0.1:8080/cgi-bin/test.py : 200 OK

    test with files containing errors to see if the error handling works properly
-> chmod +x www/html/cgi-bin/timeout.py  
-> curl -i http://127.0.0.1:8080/cgi-bin/timeout.py : 504 Timeout



===== Check with a browser =====

    Look at the request header and response header
-> DevTools (F12), Network tab, click on the request

    Try to list a directory
-> http://127.0.0.1:8080/listingDir (autoindex on)

    Try a redirected URL.
-> curl -i http://127.0.0.1:8080/go-home : 301



===== Port issues =====





In the configuration file setup multiple ports and use different websites. Use the browser to ensure that the configuration works as expected and shows the right website.


Tu as déjà tout ce qu’il faut dans les deux configs :

config/default.conf : deux blocs server, sur 8080 et 8081 (localhost-alt).
linux.conf : premier bloc écoutant 8080 et 8888, second bloc sur 8082 (api.local).
Pour la démo :

Lancer le serveur avec la config voulue, par ex.

./webserv config/default.conf
Tester les ports/hosts dans le navigateur :

http://127.0.0.1:8080/ → affiche ton site principal (index dans www/html).
http://127.0.0.1:8081/ → chargera la version localhost-alt (tu peux personnaliser ce bloc pour qu’il serve un contenu différent).
Si tu veux tester api.local (port 8082 dans linux.conf), lance ./webserv linux.conf puis, dans le navigateur, ouvre http://api.local:8082/health après avoir ajouté 127.0.0.1 api.local à /etc/hosts.
Vérifier dans DevTools (Network) que les en-têtes montrent bien Server: webserv/1.0, la bonne page, etc.

Tu peux aussi faire curl --resolve api.local:8082:127.0.0.1 http://api.local:8082/health. Chaque port/host doit renvoyer le contenu prévu dans le bloc server correspondant : c’est exactement la preuve attendue par la consigne « multiple ports et sites différents ».





